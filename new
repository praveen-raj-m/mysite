You are a senior investment analyst. Analyze the following JSON-formatted Brinson attribution data, which represents monthly performance for an investment portfolio. Your goal is to create a detailed, professional analysis suitable for presentation to clients, portfolio managers, or investment committees.

The data includes:
- Sector name
- Portfolio weighted contribution
- Benchmark weighted contribution
- Selection effect
- Allocation effect
- (Optional) Portfolio average weight
- (Optional) Benchmark average weight
- (Optional) Portfolio total return
- (Optional) Benchmark total return

Instructions:

1. For each sector, calculate the Total Management Effect as the sum of Selection Effect and Allocation Effect.

2. Rank all sectors based on Total Management Effect:
   - Identify and explain the top 3 contributors and bottom 3 detractors.

3. For each sector, analyze:
   - Whether the performance impact came from selection (security picking), allocation (sector weighting), or both.
   - If weight data is available, assess whether the sector was overweighted or underweighted relative to the benchmark.
   - If return data is available, compare the portfolio return vs. benchmark return to infer what drove the selection effect.

4. Detect and comment on any unusual patterns or red flags, such as:
   - Strong selection effect in an underweight sector
   - Negative selection in an overweighted sector
   - High active contribution in sectors with low weights
   - Sectors where allocation worked but selection failed (or vice versa)

5. Summarize the overall performance:
   - Calculate and report the total active return across all sectors.
   - Break this down into total selection effect and total allocation effect.
   - Comment on whether performance was mainly driven by allocation strategy, security selection, or a combination of both.

6. Use a client-facing, professional tone:
   - Be data-driven, constructive, and objective.
   - Avoid harsh language or blame. Instead, aim to educate and inform clearly.
   - If performance was negative, focus on causes and possible areas for improvement.

Here is the JSON data:


import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  rawInput: string = '';
  prompt: string = '';

  // Define headers explicitly (in correct order)
  yourHeaders: string[] = [
    'Industry Code',
    'Portfolio Weight',
    'Benchmark Weight',
    'Portfolio Return',
    'Benchmark Return',
    'Wgtd Contribution',
    'Selection Effect'
  ];

  generatePrompt() {
    try {
      const lines = this.rawInput.trim().split('\n');
      if (lines.length < 2) {
        this.prompt = 'Invalid table.';
        return;
      }

      // Skip the first line entirely
      const dataLines = lines.slice(1);

      // Map lines to row objects using your defined headers
      const dataRows = dataLines.map(line => {
        const values = line.split(',').map(v => v.trim());
        const row: any = {};
        this.yourHeaders.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        return row;
      });

      // Extract and remove last row (assumed to be total)
      const totalRow = dataRows.pop()!;
      const lastColumn = this.yourHeaders[this.yourHeaders.length - 1];

      // Sort by last column
      dataRows.sort((a, b) => {
        const aVal = parseFloat(a[lastColumn]) || 0;
        const bVal = parseFloat(b[lastColumn]) || 0;
        return bVal - aVal; // Descending
      });

      // Tag top 3 and bottom 3
      dataRows.forEach((row, index, arr) => {
        if (index < 3) row['Tag'] = 'Top Performer';
        else if (index >= arr.length - 3) row['Tag'] = 'Underperformer';
      });

      // Create final total object
      const totalData: any = {};
      this.yourHeaders.slice(1).forEach(header => {
        totalData[header] = totalRow[header] || '';
      });

      const finalJson = [...dataRows, { Total: totalData }];
      const jsonString = JSON.stringify(finalJson, null, 2);

      this.prompt =
        `You are a financial analyst. Analyze the following portfolio attribution data.\n\n` +
        `The table is sorted by the last column ("${lastColumn}").\n` +
        `The top 3 sectors are marked as "Top Performer", the bottom 3 as "Underperformer".\n` +
        `The last item in the list is the Total row, showing column-wise totals.\n\n` +
        `Data:\n${jsonString}`;
    } catch (err) {
      this.prompt = 'Error parsing input.';
    }
  }
}







generatePrompt() {
  try {
    const lines = this.rawInput.trim().split('\n');
    if (lines.length < 2) {
      this.prompt = 'Invalid table.';
      return;
    }

    // Hardcoded headers — ignore first line of CSV
    const headers = this.yourHeaders;
    const dataLines = lines.slice(1); // skip header line

    // Parse CSV rows using fixed headers
    const dataRows = dataLines.map(line => {
      const values = line.split(',').map(v => v.trim());
      const row: any = {};
      headers.forEach((header, index) => {
        row[header] = values[index] || '';
      });
      return row;
    });

    // Remove last row as Total
    const totalRow = dataRows.pop()!;
    const performanceCol = headers[headers.length - 1]; // Last column
    const investmentCol = 'Portfolio Weight'; // or another column

    // Sort performance & investment separately for tagging
    const performanceSorted = [...dataRows].sort((a, b) =>
      (parseFloat(b[performanceCol]) || 0) - (parseFloat(a[performanceCol]) || 0)
    );

    const investmentSorted = [...dataRows].sort((a, b) =>
      (parseFloat(b[investmentCol]) || 0) - (parseFloat(a[investmentCol]) || 0)
    );

    // Final sorted data by performance
    const sortedFinal = [...performanceSorted];

    // Tagging logic
    const tagRow = (row: any) => {
      const tags: string[] = [];

      if (performanceSorted.indexOf(row) < 3) tags.push('Top Performer');
      else if (performanceSorted.indexOf(row) >= performanceSorted.length - 3)
        tags.push('Underperformer');

      if (investmentSorted.indexOf(row) < 3) tags.push('High Investment');
      else if (investmentSorted.indexOf(row) >= investmentSorted.length - 3)
        tags.push('Low Investment');

      return tags.length > 0 ? tags : undefined;
    };

    // Apply tags
    const taggedRows = sortedFinal.map(row => {
      const tags = tagRow(row);
      return tags ? { ...row, Tags: tags } : row;
    });

    // Append Total as final entry
    const totalData: any = {};
    headers.slice(1).forEach(header => {
      totalData[header] = totalRow[header] || '';
    });

    const outputJson = [...taggedRows, { Total: totalData }];
    const jsonString = JSON.stringify(outputJson, null, 2);

    // Final prompt
    this.prompt =
      `You are a financial analyst. Analyze the following portfolio attribution data.\n\n` +
      `The table is sorted by "${performanceCol}" to assess performance, and also tagged based on "${investmentCol}".\n` +
      `Each row may include:\n` +
      `• "Top Performer" or "Underperformer" (based on performance)\n` +
      `• "High Investment" or "Low Investment" (based on portfolio weight)\n\n` +
      `The last object is the "Total" row showing column-wise totals.\n\n` +
      `Data:\n${jsonString}`;
  } catch (err) {
    this.prompt = 'Error parsing input.';
  }
}
